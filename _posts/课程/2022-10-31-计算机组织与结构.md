（前面的一些图放在github上，加载较慢或根本加载不出来，后面再传到微博图床）

# 第六章 计算机的运算方法

## 6.1
* 有符号数第一位数用来表示符号
* 无符号数只表示正数因此会比相同字长有符号数大小大约一倍
* 源码
	* “0”表示“正”，“1”表示“负”
	* 使用逗号隔开符号位和真值
* 补码
	* “模”
	* 求补码
* 反码
* 移码
	* 对真值加上一个 2 ^n
	* 即可进行数值大小的比较
## 6.2
1. 纯小数和纯整数
	* 取决于小数点的未知
	* 定点机处理非纯小数或纯整数时，必须乘上一个比例因子，否则溢出
2. 浮点表示
	* 浮点数：小数点位置可以浮动的数
	* 表示形式
	![图片](https://raw.githubusercontent.com/newbie-ID/newbie-ID.github.io/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221014173249.png)
	* 表示范围（在数轴上）
	![图片1](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221014194513.png?raw=true)
	* 规格化
## 6.3
1. 移位
	* 实质是乘以或除以2 ^n
	* 算数移位补充“0”
	* 精度丢失问题：使用带进位的移位
2. 加法与减法
	* 现代计算机采用补码进行
	* 普通溢出
	* 用两位符号位判断溢出
		* 相同表示溢出，否则无溢出
		* 溢出时第一位为0表示正溢出，反之表示负溢出
3. 乘法运算
	* 部分积的初值为0
	* 硬件上需要寄存器
	* 源码乘法
	* 补码乘法
	* booth算法
4. 除法运算
	* 恢复余数法
		* 将绝对值相减的操作替换为补码相加
		* 每加上一个补数判断一次，判断加上的商值为0还是为1
		* 若商为负则当场加上原除数恢复
	* 加减交替法
		* 相当于恢复余数法的一种改进算法
		* 若余数大于零，上商1，左移减除数
		* 若余数小于零，上商0，左移加除数
		* 与乘法相同，也可以使用补码进行运算
## 6.4
1. 浮点加减运算
	* 对阶
	* 尾数求和
	* 规格化
		* S>0时，00.1xx...x
		* S<0时，11.0xx...x
		* 负二分之一不是规格化的数，负一是规格化的数
	* 舍入
		* 0舍1入法
		* 恒置1法
	* 溢出判断
2. 浮点数乘除法运算
	* 相比整数多了对阶码的操作
	* 同样需要规格化和舍入
## 6.5
硬件
## 第六章课后习题
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192227.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192303.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192328.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192346.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192422.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192444.png?raw=true)




# 第四章 存储器
## 4.1
1. 分类
	1. 存储介质
	2. 存取方式
	3. 作用分类
2. 层次结构
	* CPU-缓存-主存-辅存
		* 速度接近缓存、高于主存
		* 容量大，价格低
## 4.2
1. 主存储器
	1. 组成：存储体、MAR（存储器地址寄存器）、MDR（存储器数据寄存器）
	2. 结构![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7ws1xlwp6j30db07bwez.jpg)
2. 存储体的组成
	1. 存储元：一个开关+一个电容器，可实现读和写
	2. 一根信号线对应的一组存储元称为存储单元
	3. 一个存储体由多个存储单元组成
	4. 无电时则无信号
	5. 可以同时取出来的电信号（MDR）：一个存储字
	6. 存储单元的数量不一样，存储字的长度也不一样，描述为存储字长（单位bit）
	7. 字长通常取8的整数倍 字节(1Byte = 8bit)
3. 主存的简单模型
	1. 要读取或写入信息只能一根信号线为1，其余信号线为0才行
	2. n位地址（MAR）输入译码器=> $2^n$ 个存储单元
	3. 总容量 = 存储单元个数×存储字长
4. 存储器芯片
	1. 将这个结构封装，芯片连接片选线、读写控制线、地址线，其余封装![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7wt338nf9j30qh0e1jy2.jpg)
	2. 单位 K: 2的10次方 M:20次方 G:30次方 T:40次方
	4. 8K = 8 × 1K = $2^3$ × $2^10$ = $2^13$
5. 寻址
	1. 假设字长为4B，总容量为1KB
	2. 按字节寻址：1K个单元，每个单元大小为**1B**，地址线10根，进行编码
	3. 按字寻址：256个单元，每个单元大小为**4B**（以存储单元为一组），高位可作为组号
	4. 按半字寻址：512个单元，每个单元大小为**2B**（同理）
	5. 按双字寻址：128个单元，每个单元大小为**8B**
	6. 存储字节方式：大端方式、小端方式
6. 半导体存储芯片
	1. 基本结构![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7wum8e76lj30hi0e0jv5.jpg)
	2. SRAM & DRAM => 静态和动态，特点与区别：![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7wv8cm40yj30r80eidmv.jpg)
	3. 使用行列地址，将 $2^n$ 条线转变为 $2^n$ 开根条线，有效减少数的数量因此刷新时以行为单位
	4. DRAM刷新方式
		1. 分散刷新：读写和刷新交替进行
		2. 集中刷新：一段时间集中用于刷新，此刻无法访问存储器
		3. 异步刷新：每个周期使用一段时间刷新一部分
	5. SRAM的读写周期
	6. CPU启动需要取指令开始工作，而RAM有断电丢失的性质，因此需要ROM，存放开机的必要信息
	7. 类型/发展历史：![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7wvu66pdwj30kp0ajn1b.jpg)
7. [存储器一节小结](https://www.bilibili.com/video/BV1BE411D7ii?p=62&vd_source=289d08d1b4920edf849b139c6c1e15d0)
8. 存储器与CPU的连接
	1. 位扩展：CPU上的数据线多于存储器芯片的数据线输入数量，进行拓展，片选信号常开（8个8Kx1位相当于一个8Kx8位的存储器）
	2. 字拓展：CPU和存储器芯片上的数据线数量一致，通过多余的地址线控制片选信号，进行位拓展，两者必须一个工作一个不工作=>地址为01xxxx或10xxxx
	3. 字拓展译码器：只用一个

# 第七章 指令系统

## 7.1
1.  指令：操作码（操作的地址）、地址码（操作对象的地址）
2.  操作码：固定长度，可变长度按设计者需求
3.  四地址：|OP|A1|A2|A3|A4|，第一操作数地址、第二操作数地址、结果地址、下一条指令地址
4.  三地址：用PC（程序计数器）代替A4，做一次取指，PC加“1”，三地址让地址空间范围增大=>用PC访问内存，先加"1"再说
5.  二地址：|OP|A1|A2| (A1)OP(A2)=>A1/A2 结果也可以存于ACC
6.  一地址：|OP|A1| (ACC)OP(A1)=>ACC
7.  零地址：无操作对象，结束指令、停机指令=>让脉冲进不去，用0来与
8.  指令字长：取决于操作码的长度、操作数地址的长度和操作数地址的个数。固定或可变，设计者规定。
9.  拓展操作码技术：？

## 7.2
1.  操作数类型：地址(无符号整数)、数字（定点数、浮点数、十进制数）、字符（ASCII码）、逻辑数（逻辑运算）
2.  存放方式：字地址和字节地址
3.  边界对准/对准边界：填充空白字节使得变成整数倍，方便调用3. 
<!--stackedit_data:
eyJoaXN0b3J5IjpbNDczMTU1MTYsMjcxNzU4ODQ4LDQ3MDgyNj
AzNywxMTQ1ODYwNDYzLC0yMTE3MTI4NzE1LDE2MjQ5OTg2Mjcs
MTA2MzkzMjQ0NV19
-->