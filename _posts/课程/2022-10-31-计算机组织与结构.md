（前面的一些图放在github上，加载较慢或根本加载不出来，后面再传到微博图床）

# 第六章 计算机的运算方法

## 6.1
* 有符号数第一位数用来表示符号
* 无符号数只表示正数因此会比相同字长有符号数大小大约一倍
* 源码
	* “0”表示“正”，“1”表示“负”
	* 使用逗号隔开符号位和真值
* 补码
	* “模”
	* 求补码
* 反码
* 移码
	* 对真值加上一个 2 ^n
	* 即可进行数值大小的比较
## 6.2
1. 纯小数和纯整数
	* 取决于小数点的未知
	* 定点机处理非纯小数或纯整数时，必须乘上一个比例因子，否则溢出
2. 浮点表示
	* 浮点数：小数点位置可以浮动的数
	* 表示形式
	![图片](https://raw.githubusercontent.com/newbie-ID/newbie-ID.github.io/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221014173249.png)
	* 表示范围（在数轴上）
	![图片1](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221014194513.png?raw=true)
	* 规格化
## 6.3
1. 移位
	* 实质是乘以或除以2 ^n
	* 算数移位补充“0”
	* 精度丢失问题：使用带进位的移位
2. 加法与减法
	* 现代计算机采用补码进行
	* 普通溢出
	* 用两位符号位判断溢出
		* 相同表示溢出，否则无溢出
		* 溢出时第一位为0表示正溢出，反之表示负溢出
3. 乘法运算
	* 部分积的初值为0
	* 硬件上需要寄存器
	* 源码乘法
	* 补码乘法
	* booth算法
4. 除法运算
	* 恢复余数法
		* 将绝对值相减的操作替换为补码相加
		* 每加上一个补数判断一次，判断加上的商值为0还是为1
		* 若商为负则当场加上原除数恢复
	* 加减交替法
		* 相当于恢复余数法的一种改进算法
		* 若余数大于零，上商1，左移减除数
		* 若余数小于零，上商0，左移加除数
		* 与乘法相同，也可以使用补码进行运算
## 6.4
1. 浮点加减运算
	* 对阶
	* 尾数求和
	* 规格化
		* S>0时，00.1xx...x
		* S<0时，11.0xx...x
		* 负二分之一不是规格化的数，负一是规格化的数
	* 舍入
		* 0舍1入法
		* 恒置1法
	* 溢出判断
2. 浮点数乘除法运算
	* 相比整数多了对阶码的操作
	* 同样需要规格化和舍入
## 6.5
硬件
## 第六章课后习题
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192227.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192303.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192328.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192346.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192422.png?raw=true)
![](https://github.com/newbie-ID/newbie-ID.github.io/blob/main/%E5%9B%BE%E7%89%87%E4%BF%9D%E5%AD%98/Pasted%20image%2020221016192444.png?raw=true)




# 第四章 存储器
## 4.1
1. 分类
	1. 存储介质
	2. 存取方式
	3. 作用分类
2. 层次结构
	* CPU-缓存-主存-辅存
		* 速度接近缓存、高于主存
		* 容量大，价格低
## 4.2
1. 主存储器
	1. 组成：存储体、MAR（存储器地址寄存器）、MDR（存储器数据寄存器）
	2. 结构![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7ws1xlwp6j30db07bwez.jpg)
2. 存储体的组成
	1. 存储元：一个开关+一个电容器，可实现读和写
	2. 一根信号线对应的一组存储元称为存储单元
	3. 一个存储体由多个存储单元组成
	4. 无电时则无信号
	5. 可以同时取出来的电信号（MDR）：一个存储字
	6. 存储单元的数量不一样，存储字的长度也不一样，描述为存储字长（单位bit）
	7. 字长通常取8的整数倍 字节(1Byte = 8bit)
3. 主存的简单模型
	1. 要读取或写入信息只能一根信号线为1，其余信号线为0才行
	2. n位地址（MAR）输入译码器=> $2^n$ 个存储单元
	3. 总容量 = 存储单元个数×存储字长
4. 存储器芯片
	1. 将这个结构封装，芯片连接片选线、读写控制线、地址线，其余封装![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7wt338nf9j30qh0e1jy2.jpg)
	2. 单位 K: 2的10次方 M:20次方 G:30次方 T:40次方
	4. 8K = 8 × 1K = $2^3$ × $2^10$ = $2^13$
5. 寻址
	1. 假设字长为4B，总容量为1KB
	2. 按字节寻址：1K个单元，每个单元大小为**1B**，地址线10根，进行编码
	3. 按字寻址：256个单元，每个单元大小为**4B**（以存储单元为一组），高位可作为组号
	4. 按半字寻址：512个单元，每个单元大小为**2B**（同理）
	5. 按双字寻址：128个单元，每个单元大小为**8B**
	6. 存储字节方式：大端方式、小端方式
6. 半导体存储芯片
	1. 基本结构![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7wum8e76lj30hi0e0jv5.jpg)
	2. SRAM & DRAM => 静态和动态，特点与区别：![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7wv8cm40yj30r80eidmv.jpg)
	3. 使用行列地址，将 $2^n$ 条线转变为 $2^n$ 开根条线，有效减少数的数量因此刷新时以行为单位
	4. DRAM刷新方式
		1. 分散刷新：读写和刷新交替进行
		2. 集中刷新：一段时间集中用于刷新，此刻无法访问存储器
		3. 异步刷新：每个周期使用一段时间刷新一部分
	5. SRAM的读写周期
	6. CPU启动需要取指令开始工作，而RAM有断电丢失的性质，因此需要ROM，存放开机的必要信息
	7. 类型/发展历史：![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7wvu66pdwj30kp0ajn1b.jpg)
7. [存储器一节小结](https://www.bilibili.com/video/BV1BE411D7ii?p=62&vd_source=289d08d1b4920edf849b139c6c1e15d0)
8. 存储器与CPU的连接
	1. 位扩展：CPU上的数据线多于存储器芯片的数据线输入数量，进行拓展，片选信号常开（8个8Kx1位相当于一个8Kx8位的存储器）
	2. 线选法字拓展：CPU和存储器芯片上的数据线数量一致，通过多余的地址线控制片选信号，进行位拓展，两者必须一个工作一个不工作=>地址为01xxxx或10xxxx
	3. 译码片选法：只用一个地址线，直接连接一个存储器芯片，连接一个取反连接另外一个芯片，达成用一个地址线控制两个芯片的效果=>译码器的n条线对应 $2^n$ 个片选信号。
	4. 高/低电平有效：片选线取反，译码器输出取反。低电平译码器有多个“使能”端，功能类似片选线，能让译码器开始工作。
	5. 字位同时扩展：片选信号同时输送到两个存储器芯片
9. [例题](https://www.bilibili.com/video/BV1BE411D7ii?p=64&vd_source=289d08d1b4920edf849b139c6c1e15d0)
10. 处理速度慢：双口RAM和多模块存储器
	1. 双口RAM：一块RAM连接两块CPU，不能同时工作，需要输出两个“忙”线控制单CPU工作，效率低且需要多接两根线，只有两块CPU之间需要交流的时候用到。
	2. 多模块存储器： 
		1. 单体多字存储器：每行拓展存储单元（原来每行为1个存储单元，拓展为每行m个存储单元）=>总线宽度拓展；存储指令和数据必须连续存放。
		2. 多体并行存储器：每个模块有相同容量和存取速度，各模块独立读写控制电路、地址寄存器和数据寄存器；可并行工作也可独立工作
			1. ![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h84sgmzxaej30r40dfjxg.jpg)
			2. 使用流水线进行提速：存取周期，可计算总线
10. 局部性原理
	1. 空间局部性：最近的未来要用的信息很可能存储在临近的空间。
	2. 时间局部性：最近未来要用的信息很可能是现在正在使用的信息。
	3. Cache使用：当数据读取时，Cache同时读取目的数据邻近的数据（单位是机器字长，数量是2的n次方），接下来就是地址读取线和Cache交流
	4. 命中率H：CPU欲访问的信息已在Cache中的比率
	5. 缺失率M：1-H
	6. 通过命中所需时间和失效所耗时间计算得到平均访问时间。
10. Cache的基本工作原理
	1. 地址映射
		1. 全相联映射：Cache中有效位表示该块地址是否有数据；传递主存数据时将前面的地址位同时传给Cache，便于区分；|主存字块标记|字块内地址|
		2. 直接映射：不需要保存行号，只需要保存高位|主存字块标记|Cache字块地址|字块内地址|=>对空位的利用率低但更容易存放更多信息，识别地址
		3. 组相连映射：|主存字块标记|组地址|字块内地址|
		4. ![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h84w67z6z0j30v40eytel.jpg)
	2. 替换算法
		1. 替换装置：相联存储器
		2. 随机算法
		3. 先进先出算法
		4. 近期最少使用算法：每出现一次计数器清零，在需要替换时，删除最晚命中的那个
		5. 最不经常使用算法：总数少的被替换
	3. 地址映射方法和替换算法结合综合出题
	4. 写策略-命中
		1. 写回法：设置一个脏位，如有修改，脏位变化，再决定是否写回
		2. 全写法：CPU对Cache写命中时，把数据同时写入Cache和主存，一般使用写缓冲
	5. 写策略-未命中
		1. 写分配法：把主存中的块调回Cache，在Cache中修改。（搭配写回法）
		2. 若搭配全写法还需要一个写缓冲区
	6. 解决方法：多级cache![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h84xfy7xamj30rs09kdgl.jpg)
11. 虚拟存储器
	1. 底层物理硬件对系统、用户透明
	2. 用户给出地址，称为虚地址或逻辑地址，由软件给编成映射到主存中的单元地址（这些地址称为实地址或物理地址）
	3. 页：![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h84yz4wu6gj30sc0da40g.jpg)
	4. 段：两者区别在于长度是否固定![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h84z0d8ynmj30lq0exgof.jpg)
	5. 段页式：先分段再分页（表比较多，耗时长）
	6. 快表TLB 用高速缓存放常用的页表项
# 第七章 指令系统

## 7.1
1.  指令：操作码（操作的地址）、地址码（操作对象的地址）
2.  操作码：固定长度，可变长度按设计者需求
3.  四地址：|OP|A1|A2|A3|A4|，第一操作数地址、第二操作数地址、结果地址、下一条指令地址
4.  三地址：用PC（程序计数器）代替A4，做一次取指，PC加“1”，三地址让地址空间范围增大=>用PC访问内存，先加"1"再说
5.  二地址：|OP|A1|A2| (A1)OP(A2)=>A1/A2 结果也可以存于ACC
6.  一地址：|OP|A1| (ACC)OP(A1)=>ACC
7.  零地址：无操作对象，结束指令、停机指令=>让脉冲进不去，用0来与
8.  指令字长：取决于操作码的长度、操作数地址的长度和操作数地址的个数。固定或可变，设计者规定。
9.  拓展操作码技术：？

## 7.2
1.  操作数类型：地址(无符号整数)、数字（定点数、浮点数、十进制数）、字符（ASCII码）、逻辑数（逻辑运算）
2.  存放方式：字地址和字节地址
3.  边界对准/对准边界：填充空白字节使得变成整数倍，方便调用
4. 操作类型
	1. 数据传送，如MOVE、PUSH、POP等操作，8086无存储器之间的数据传送。
	2. 算术逻辑操作。整体或对位的操作
	3. 移位操作
	4. 转移。无条件转移（goto）、条件转移、调用与返回（函数调用）、陷阱与陷阱指令（出现事故系统调用）、输入输出。

## 7.3
1. 指令寻址，顺序寻址执行后PC+1，跳跃寻址，通过转移类指令调整PC的值，达到跳跃的效果
2. 数据寻址
	1. 一种格式：|操作码|寻址特征|形式地址A|，约定 指令字长 = 存储字长 - 机器字长
	2. 立即寻址：|OP|#|A|，#立即寻址特征，A就是操作数本身，可不访问存储器。
	3. 直接寻址：|OP|  |A|，只访问一次主存
	4. 隐含寻址：不明显地给出操作数的地址，如访问ACC中的数据
	5. 间接寻址：进行两次寻址，一次直接寻址访问主存，再访问主存中的地址，取出另外一个操作数（一次间址）=>多次间址。调用子函数也能用这个思路。
	6. 寄存器直接寻址：直接指向寄存器内的操作数，无须访问内存。
	7. 寄存器间接寻址：访问寄存器，里面存的是内存的地址，指向内存的操作数。（i++，寄存器命令。i=i+1，多访问两次内存）
	8. 变址寻址
		1. ![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h80y0rmkp1j30px0eh42o.jpg)
		2. A相当于数组名称，IX相当于下标，加起来可取出对应下标的主存操作数。
		3. 通用寄存器可理解为可存放二维数组
	9. 基址寻址
		1. 其他一样，寄存器不一样
		2. BR内容由系统操作而定，用户一般不能修改
		3. 用户只能修改A达到修改的目的
		4. 有利于多道程序
	10. 相对寻址
		1. |OP|寻址特征|A|
		2. A和PC进入ALU，寻址可找到相对于当前地址的浮动地址。
		3. 有利于编写浮动程序
		4. 注意PC在取值后会+1，浮动的相对变化需要考虑
		5. 例题7.2很经典
	11. 堆栈寻址
		1. 进栈出栈的内存寻址
## 7.4&7.5 简单了解

# 第8章 CPU的结构和功能

## 8.1
## 8.2
1. 周期取指：取指周期->（间指周期）->执行周期->（中断周期）
2. 取指周期的数据流
	1. 一开始总是从PC开始，PC把地址传送给MAR
	2. CU连接控制总线再连接存储器
	3. 存储器把数据传给数据总线
	4. 数据总线把数据传给MDR
	5. MDR把数据返还给IR
3. 间址周期的数据流![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h88z0fzb6ij30f808ot9u.jpg)
4. 执行周期
5. 中断周期
6. 指令流水

# 第九章 
## 9.2
1. 多级时序系统
	1. 机器周期
		1. 基准时间：以最复杂指令功能的时间为准
		2. 以访问一次存储器（方式：同步还是异步）的时间为基准
	2. 时钟周期（节拍、状态）
		1. 控制机器操作的最小周期
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTE0MTg0MzE2LDE0NjgyOTkwODcsNDA1NT
M2MzM4LDEwODgwNDE4NjAsNzIyMDE2MTUzLDc3NTk0NjI4LC0x
MDQ4OTIzNzUwLC0xMDEwODYyMjg0LDIwOTYyODc0MzksLTE5NT
EwMjExMzIsMjExNzkwMjY0OCw2NjAxMzk4OTgsLTExNDQyNDU1
MDAsLTE0MDc2MDMyNTMsLTE1NDM5NTUwNjEsLTY5NjM3MzQ3Ny
wtMTczNzAzNzIxMiw1MzU4MTMxNjIsLTIxMDIxMTY5NDIsLTEz
MjA3NDI1OTldfQ==
-->