## 第十二章
### 12.1
### 12.2
### 12.3
### 12.4
1. 大根数 每个节点大于等于其子节点（小根数反之）=>大（小）根堆
2. 大根堆的插入：插入新节点然后起泡
3. 大根堆的删除：将要删除的节点放在根节点，删除后冒泡，朝下冒泡：选择子树中较大的那一个
4. 大根堆的初始化：用完全二叉树的方式编码，从最后一个有孩子的节点开始检查，一步步向上走调整为大根堆
### 12.5
1. 扩充二叉树
	1. 用外部节点代替树中的空子树
	2. 其余节点叫做内部节点
	3. 有外部节点=>扩充二叉树
	4. 函数s(x) => x到其子树的外部节点最短路径+1
	5. w(x)=>x及x所有子节点的个数
2. 高度优先左高树
	1. 其中任何一个内部节点的左孩子的s值大于等于右孩子的s值
	2. ![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7yvgvh7o4j30ma03kdh1.jpg)
	3. 最大HBLT（是HBLT的同时还是大根树），最小HBLT同理
3. 重量优先左高树
	1. 定义：任何一个内部节点左孩子的w值大于右孩子
4. 对HBLT的操作
	1. 合并：最好用递归实现，有空=>直接合并再调整，无空=>较大者作为合并后的根
	2. ![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7yweqi59kj30oe0ht782.jpg)
	3. 初始化：创造n个一个元素的最大HBLT，组成一个FIFO队列，合并插入对尾直到只有一棵HBLT
5. 霍夫曼编码
	1. 根据不同符号在一段文本中相对出现的频率进行编码。
	2. 霍夫曼树（好丑，回去慢慢画）=>生成的编码：霍夫曼编码![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7ywxf1hc1j306o08lmxx.jpg)
	3. a、x、u、z：3、2、1、1=>0=a,10=x,110=u,111=z
	4. 构建一棵霍夫曼树：![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7yx3uhptzj30fn0do76r.jpg)


## 第十三章
选讲+讲不完=不讲。

## 第十四章
### 14.1
1. 二叉搜索树定义：可能为空的二叉树；每个元素有唯一关键词；不空的二叉树左子树关键词小于根节点，右子树大于。
2. 若关键词可重复=>有重复值的二叉搜索树
3. 索引二叉搜索树=>每个节点添加一个leftSize值，保存该节点左子树的个数。
### 14.2
伪代码

### 14.3
代码实现：
1. 输出
2. 查找
3. 插入
4. 删除
	1. 删除叶节点：直接释放
	2. 删除一个度为1的节点：直接跳过删除节点指向删除节点的孩子
	3. 删除一个度为2的节点：用删除节点左子树里面最大的或右子树里面最大的元素来替换删除节点。

### 14.4
带有相同关键字元素的二叉搜索树：将一部分大于/小于改为大于等于/小于等于。

## 第十五章
### 15.1
1. 定义：最坏情况下高度为O（logn）的树为平衡树，AVL树是一种平衡树。
2. 平衡因子bf(x)=x左子树高度 - x右子树高度，平衡因子的可能取值为-1、0、1
3. 插入：按照AVL方法插入节点，再进行恢复平衡
4. 插入节点：找到小于插入数据的左子树，在该树中找到小于的右子树，遍历插入...右子树同理。
5. 恢复平衡方式：四种情况LL、LR、RR、RL（有一点点绕）
6. 书上AVL树插入步骤。（再看看）
7. 删除：R0、R1、R-1（L镜像同理）
8. 练习题

### 15.4
1. ISAM方法
	1. 顺序访问：依次输入各个块，在每个块中按照升序搜索元素。每个块包含m个元素，则搜索每个元素所需访问次数为1/m（理解为读入了cache）
	2. 随机访问：维持一个索引。包含每个块的最大关键字，访问元素的关键字=>查找索引表=>取出相应的块进行内部搜索。
	3. 跨磁盘访问=>先访问内存中的磁盘=>取出相应的块
	4. 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTkwMjYxMDIwOCwtMTY4NjI1NTMwNiwtMj
A2ODc4MTA3OF19
-->