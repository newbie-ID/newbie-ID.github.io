## 第十二章
### 12.1
### 12.2
### 12.3
### 12.4
1. 大根数 每个节点大于等于其子节点（小根数反之）=>大（小）根堆
2. 大根堆的插入：插入新节点然后起泡
3. 大根堆的删除：将要删除的节点放在根节点，删除后冒泡，朝下冒泡：选择子树中较大的那一个
4. 大根堆的初始化：用完全二叉树的方式编码，从最后一个有孩子的节点开始检查，一步步向上走调整为大根堆
### 12.5
1. 扩充二叉树
	1. 用外部节点代替树中的空子树
	2. 其余节点叫做内部节点
	3. 有外部节点=>扩充二叉树
	4. 函数s(x) => x到其子树的外部节点最短路径+1
	5. w(x)=>x及x所有子节点的个数
2. 高度优先左高树
	1. 其中任何一个内部节点的左孩子的s值大于等于右孩子的s值
	2. ![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7yvgvh7o4j30ma03kdh1.jpg)
	3. 最大HBLT（是HBLT的同时还是大根树），最小HBLT同理
3. 重量优先左高树
	1. 定义：任何一个内部节点左孩子的w值大于右孩子
4. 对HBLT的操作
	1. 合并：最好用递归实现，有空=>直接合并再调整，无空=>较大者作为合并后的根
	2. ![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7yweqi59kj30oe0ht782.jpg)
	3. 初始化：创造n个一个元素的最大HBLT，组成一个FIFO队列，合并插入对尾直到只有一棵HBLT
5. 霍夫曼编码
	1. 根据不同符号在一段文本中相对出现的频率进行编码。
	2. 霍夫曼树（好丑，回去慢慢画）=>生成的编码：霍夫曼编码![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7ywxf1hc1j306o08lmxx.jpg)
	3. a、x、u、z：3、2、1、1=>0=a,10=x,110=u,111=z
	4. 构建一棵霍夫曼树：![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h7yx3uhptzj30fn0do76r.jpg)


## 第十三章
选讲+讲不完=不讲。

## 第十四章
### 14.1
1. 二叉搜索树定义：可能为空的二叉树；每个元素有唯一关键词；不空的二叉树左子树关键词小于根节点，右子树大于。
2. 若关键词可重复=>有重复值的二叉搜索树
3. 索引二叉搜索树=>每个节点添加一个leftSize值，保存该节点左子树的个数。
### 14.2
伪代码

### 14.3
代码实现：
1. 输出
2. 查找
3. 插入
4. 删除
	1. 删除叶节点：直接释放
	2. 删除一个度为1的节点：直接跳过删除节点指向删除节点的孩子
	3. 删除一个度为2的节点：用删除节点左子树里面最大的或右子树里面最大的元素来替换删除节点。

### 14.4
带有相同关键字元素的二叉搜索树：将一部分大于/小于改为大于等于/小于等于。

## 第十五章
### 15.1
1. 定义：最坏情况下高度为O（logn）的树为平衡树，AVL树是一种平衡树。
2. 平衡因子bf(x)=x左子树高度 - x右子树高度，平衡因子的可能取值为-1、0、1
3. 插入：按照AVL方法插入节点，再进行恢复平衡
4. 插入节点：找到小于插入数据的左子树，在该树中找到小于的右子树，遍历插入...右子树同理。
5. 恢复平衡方式：四种情况LL、LR、RR、RL（有一点点绕）
6. 书上AVL树插入步骤。（再看看）
7. 删除：R0、R1、R-1（L镜像同理）
8. 练习题

### 15.4
1. ISAM方法
	1. 顺序访问：依次输入各个块，在每个块中按照升序搜索元素。每个块包含m个元素，则搜索每个元素所需访问次数为1/m（理解为读入了cache）
	2. 随机访问：维持一个索引。包含每个块的最大关键字，访问元素的关键字=>查找索引表=>取出相应的块进行内部搜索。
	3. 跨磁盘访问=>先访问内存中的磁盘=>取出相应的块
	4. 插入删除难，解决方法：在每个块中预留一些空间
2. m叉搜索树
	1. 定义![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h8cqf7tjrgj30qv08sdjo.jpg)
	2. 搜索、插入、删除
3. m阶B-树
	1. 非空B-树定义：
		1. 根节点至少有两个孩子
		2. 除根节点，所有内部节点至少有[m/2]（向上取整）个孩子
		3. 所有外部节点在同意层
	2. 同时满足m叉树和B-树
		1. 2阶B-树 是一棵满二叉树（所有内部节点恰好有两个孩子）
		2. 3阶B-树 可2可3 2-3树
		3. 4阶B-树 2-3-4树
	3. 高度![image.png](https://tva1.sinaimg.cn/large/006xYMUYly1h8crhnqdyrj30ol03w3zb.jpg)
	4. 搜索：与m叉搜索树算法一致
	5. 插入：直接插入或分裂节点插入到父节点，情况不好有可能会递归插入
	6. 删除
		1. 当删除元素在非根节点中，且元素为最小值
			1. 相邻兄弟有多余节点，从左右兄弟中选取多余节点替换删除节点（移回父节点、替换节点）
			2. 删除节点后，与父节点合并成新节点（可能递归使用，总高度变化）
			3. 一起使用，删除节点后在父节点再使用替换
4. B+树
	1. 叶节点中保存子树的关键字
	2. 查找方式有从小关键字顺序查找或从根节点随机查找
	3. 插入：双亲节点包含两个节点最大的关键字
	4. 删除：和B-树类似

## 第十六章
1. 图：一个用线或边连接在一起的顶点或节点的集合。
2. 有向图—无向图
3. 加权
4. 应用：
	1. 路径问题
	2. 生成树=>联通图由一个点出发到其他节点的路径=>权最小的树是最小生成树
5. 邻接矩阵
	1. 无向图的矩阵是对称的，只用存上（下）三角
	2. 有向图
6. 邻接链表
	1. 每个节点存储与这个节点直接相连的节点，存储指向方向
7. 加权图（网络）
	1. 矩阵中存储权重，不联通的路径记做无穷大
	2. 链表描述多存储一个权重的数据
	3. 数组不好描述
8. 图的遍历
	1. 搜索方式：向箭头方向寻找，找到了不重复的所有点，记做第几次找到（标记上，之后判断是否有标记）
	2. 使用队列
	3. 广度优先算法
	4. 深度优先算法
	5. 复杂性比较：高度小使用广度优先，否则使用深度优先
9. 应用
	1. 递归选择一条路径
	2. 判断无向图是否联通
	3. 生成树（广度优先生成树、深度优先生成树）

## 第十七章
1. 最优化问题
	1. 核心：局部最优的累积为整体的最优
	2. 单位最优
	3. 每一步最优得到最后的结果最优，如果有其中有一步不是最优，则不能用最优化问题
2. 贪婪算法
	1. 思想：把所有问题转换为一个个的累加起来形成整体自由解
	2. 最短路径问题
	3. 0/1背包问题
3. 拓扑：代码问题和求所有拓扑序列（使用树）再看看
4. 单源最短路径
	1. 要求：长度（耗费）>=0
	2. Dijkstra算法：分布求顶点 一步步列最短的路径
	3. 回找最近节点
5. Kruskal算法
	1. 从小到大开始寻找代价最小的路径，依次连接
	2. 如果已经构成了环，则不连接
6. Prim算法
	1. 从单一顶点的树开始
	2. 依次选择代价最小的边和点添加
	3. 直到包含n-1条边未知
7. Sollin算法
	1. 是森林的算法
	2. 了解，上面两种掌握

## 第十八章
1. 把问题拆解分别解决小问题，组成原问题的解
2. 归并排序、快速排序、选择排序
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTgxMzA5NDk1MywtNzkyNjAzNTY4LC0zNj
E3NzMwODIsLTMzMjYyMzgwNiwxMzAwNzE4NDYyLDEzMTA0OTc0
MSwxNjEyMTI4OSwxNjEwOTUwNjc5LDE2NzA0NTExNzUsOTA3MD
U0NzAsMjAwODgxMDI2Miw3NTQxODI5ODAsMjQ0MTM1MjUzLC03
Mjk1NzU0OTEsLTkwNzYyMDMyMiwtNDQ1NjE1MDYyLC00NDE5Nj
ExMjEsMjEwNDc1NjI2NywtMTYzMjAwODEyMiwtNjk4NzMwODA3
XX0=
-->